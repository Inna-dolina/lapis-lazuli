################################################################################
# Copyright <%= config[:year] %> spriteCloud B.V. All rights reserved.
# Generated by LapisLazuli, version <%= config[:lapis_lazuli][:version] %>
# Author: "<%= config[:user] %>" <<%= config[:email] %>>

# interactions_steps.rb is used to interact with elements on the page.
# Quite advances piece of regex. Goto http://rubular.com/ for practise
# Whatever is put between parenthesis is captured as a variable unless you start with `?:`
# /(?: text)?/ means: ` text` is optional and do not capture it as a variable
# /(.*?)/ means: Any amount of any character, but don't be "greedy"
# "greedy" means, do not take characters that match the rest of the regex.
Given(/^the user navigates to (?:the )?"(.*?)"(?: page)?$/) do |page|
  Nav.to(page)
end

# An example of interacting with some elements
Given(/^the user searches for "(.*?)"$/) do |query|
  # Get the input element
  searchbox = browser.find(:text_field => {:name => "s"})
  # Make sure the input field is empty
  searchbox.clear rescue log.debug "Could not clear searchbox"
  # Fill in the query
  searchbox.send_keys(query)
  # Press enter to submit the search
  searchbox.send_keys(:enter)
end


Then(/^text "([^"]*)" should display somewhere on the page$/) do |string|
  browser.wait(:html => /#{string}/i)
end

When(/^the user clicks on link "(.*?)"$/) do |url|
  # Search for the element that includes the expected text
  browser.wait(
    :like => {
      :element => :a,
      :attribute => :href,
      :include => url
    }
  ).click
end

When(/^the user clicks on the spritecloud logo$/) do
  # Search for the logo
  logo = browser.find(
    :like => [:img, :id, 'logo'],
    :message => 'Unable to find the logo on this page.'
  )
  # And click the logo
  logo.click
end

Then(/^the user should be on page "(.*?)"$/) do |page|
  url = Nav.set_url page
  Nav.wait_for_url url
end


# A step definition is a regex, to learn more about this go to http://rubular.com/
# The following step definition accepts both:
# - the user logs in > will use the last stored user data
# - "user-x" logs in > will load user data from config.yml
When(/^"?(.*?|the user)"? logs in$/) do |user_tag|
  if user_tag != 'the user'
    # Set the user data
    set_user_data(user_tag)
  end
  # Fill in the user form
  browser.find(
    :like => [:input, :id, 'login-username']
  ).set(get_user_data('username'))
  browser.find(
    :like => [:input, :id, 'login-password']
  ).set(get_user_data('password'))

  # Press the submit button
  browser.find(
    :like => [:button, :id, 'button-login']
  ).click
end

When(/^the user clicks on the logout button$/) do
  # pending # This is an example

  # First get the header to use as a context for the logout button
  header = browser.wait(:like => [:nav, :class, 'navbar-fixed-top'])

  # Then click the logout button (in this case, first a drop down needs to be clicked, before the logout button shows)
  browser.find(
    :like => [:a, :id, 'user_dropdown'],
    :context => header,
    :message => 'Unable to click on the user icon'
  ).click
  dropdown = browser.wait(
    :like => [:ul, :class, 'dropdown-menu'],
    :timeout => 5,
    :message => 'The user dropdown didn`t become present.'
  )
  browser.find(
    :like => [:a, :id, 'link-logout'],
    :context => dropdown,
    :error => 'Failed to click the logout button.'
  ).click
end

When(/^"(.*?)" registers for a new account$/) do |user_tag|
  # pending # Write code here that turns the phrase above into concrete actions

  # Set the user data
  set_user_data(user_tag)

  # Go to the registration page
  step 'the user navigates to the "training-page" page'
  browser.find(:like => [:button, :id, 'button-register']).click

  # Fill in the form

  # Get the form container and use it as a context to find the fields
  form = browser.wait(:like => [:form, :id, 'form-register'])

  # Fill in the details
  browser.find(:element => {:name => 'username'}, :context => form).set get_user_data('username')
  browser.find(:element => {:name => 'password'}, :context => form).set get_user_data('password')

  # Select gender
  browser.find(
    :label => {:text => /#{get_user_data('gender')}/i},
    :context => form,
    :message => "Unable to find gender `#{get_user_data('gender')}`, are you sure it's an option to select??"
  ).click

  # Select experiences from the multi-select list
  multi_selector = browser.find(:like => [:select, :id, "register-experience"], :context => form)
  experiences = get_user_data('experience')
  # Experiences is a list of words comma separated, EG `Ruby,Cucumber,Watir`
  # The following function will cut text at every comma, and loop trough every separate word
  experiences.split(',').each do |exp|
    option = browser.find(
      :option => {:value => /#{exp}/i},
      :context => multi_selector
    )
    option.click
  end

  # Fill in the biagraphy
  browser.find(
    :like => [:textarea, :id, 'register-bio']
  ).send_keys(get_user_data('biography'))

  # Click the accept policy checkbox
  browser.find(:like => [:input, :id, 'register-complete-all']).click

  # Press the submit button
  browser.find(:button => {:id => 'button-save'}).click

  # Wait for the success message to display
  browser.wait(
    :like => [:div, :class, 'alert-success'],
    :message => 'The successfully registered message did not display.'
  )

  # The website we're testing on, doesn't log in the user automatically. So let's trigger that step manually
  step 'the user logs in'
end

Then /^the text "(.*?)" should display on the blog page$/ do |expected_text|
  # Many things wrong here, can you fix it?
  header = browser.find(:like => [:h2, :id, 'entry_title'])
  unless heeder.text.include? expected_text
    error "Unable to find text `#{expected_text}`"
  end
end